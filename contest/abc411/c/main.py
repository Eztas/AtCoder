N, Q = map(int,input().split())
A = list(map(int,input().split()))

# 白を0, 黒を1とする, 左右1列
# 黒の区間を求める=白と黒の境目(異なる色同士)の数がわかれば良い
# 0, 0, 0, 0, 0
# 0, 1, 0, 0, 0 # 境目が2つ追加される(1区間で境目は2つなので、1/2)
# 0, 1, 1, 0, 0 # 境目が1つ消えて、1つ追加される(=変わらない)
# 0, 1, 0, 1, 0 # 境目が2つ増える(=区間が1つ増える)
# 0, 1, 0, 0, 0 # 境目が2つ減る(=区間が1つ減る)
# いちいち数を数えるためにforループを回すと計算量がかかるが
# 01反転の際に生じる境目の変動を管理すれば、forループはいらない

# 例外
# 先頭や後ろだけが変わる時
# 1, 0, 0, 0, 0 # 境目は1だが、黒の区間は1つ
# 1, 1, 0, 0, 0 # 境目は1だが、黒の区間は1つ

# 先頭も後ろも変わる時
# 1, 0, 0, 0, 1 # 境目は2だが、黒の区間は2つ

# 擬似的に先頭と後ろに白を追加しておくと、上記の場合でも境目が通常時と同じ
# = 先頭や最後が黒に変わっても、前や後に城があることで、境目が2つ増減

# 最初は全て白という前提だからこそ、境目の増減=>黒の数と同じになる
# 前の境目処理(必ず1増えるか1減る)
# 0, 0 -> 0, 1 +1
# 0, 1 -> 0, 0 -1
# 1, 0 -> 1, 1 -1
# 1, 1 -> 1, 0 +1

# 後の境目処理(必ず1増えるか1減る)
# 0, 0 -> 1, 0 +1
# 0, 1 -> 1, 1 -1
# 1, 0 -> 0, 0 -1
# 1, 1 -> 0, 1 +1

line = [0] * (N+2) # 先頭と最後が反転した時の境目処理のために、先頭と最後に白を追加
borderCount = 0  # 境目の数
for a in A:
    # 前の境目の処理
    if line[a] == line[a-1]: # 両方同じ値なら反転で境目が増える 
        borderCount += 1
    else:              # 両方違う値なら反転で境目が減る
        borderCount -= 1

    # 後の境目の処理
    if line[a] == line[a+1]: # 両方同じ値なら反転で境目が増える 
        borderCount += 1
    else:              # 両方違う値なら反転で境目が減る
        borderCount -= 1
    line[a] = 1 - line[a]  # 境目の数更新の後line[a]の色を反転
    print(borderCount//2) # 境目の数は黒区間の数の2倍なので、2で割る
