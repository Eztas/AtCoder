T = int(input())
# &演算をすれば、集合 i の中に、すでに薬品 j が含まれているか？をチェックできる
# 101 & 001 → 001 (結果は0ではない) → 薬品1は集合iに含まれている。
# 101 & 010 → 000 (結果は0) → 薬品2は集合iに含まれていない。
# |演算をすれば、加算ができる, i | (1 << j), 例: iが5 (2進数で101)、jが1の場合101 | 010 → 111 (10進数で7)
# 
# 動的計画法も最大値を見つける動的計画法と
# 0か1の2値のどちらになるのかを見つける動的計画法がある
# 1の状態に辿り着けるのか、2の状態に辿り着けるのか‥を永遠に繰り返す
# そもそも加算しかしない、戻らないから、2の状態で辿り着けたらそれまでは必ず担保される
# こういう戻ることを気にしなくていいとき、動的計画法がささる
# 今回みたいな、1次元配列の動的計画法もありうる

for t in range(T):
    N = int(input()) # 薬の種類, 薬を種類の数だけ混ぜる
    S = input() # 混ぜて状態iの時の危険度を示す

    if S[-1] == '1': # Sの末尾が1なら確実に無理, 全ての薬品を混ぜるので最後が危険だとどうしても無理
        print('No')

